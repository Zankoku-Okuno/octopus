TODO

General
	better pretty-print
		show as octopus parses, not as haskell does
		apply judicious indentation
		the angle brackets are ambiguous, use #<...>
	first-class patterns?
	serialize values, even mutable cells and the current program state
	consider putting types into the grammar, unchecked of course

Parser
	letrec
	atom ::= ... | ':(' /<name>:/ <expr>+ ')' | /@<name>/ | @(' /<name>:/ <expr>+ ')' | /\.<expr>/ | '.(' <expr>+ ')'
		@ is prefix, : and . are infix
	indentation sensitivity
	distfixes
		directives are line tht start with #! (though #! on very first line is ignored)
		massage the input by blanking these lines, but also collect and parse the directives
	anonymous points
	block comments
	primitive literals
	heredocs
	bytes literals
	documentation on a (define? export?)
	decorators in do blocks?
	ellipsis?
	assertion syntax?
	export form in file
		currently, it exports the whole environment
		a way to give out a limited set would be very useful
		exprort ::= 'export' <pattern>
	import form objects
		{x, y, z: foo} === {x: x, y: y, z: foo}
	literals for closures, tags, handlers, &c (using #<...> syntax)?
	special syntax for lambda and vau
		use the primitive ones, allow for stuff like (\l (x y z) body)
		nah, I can do this in userland

Interpreter
	Data primitives
		eq
		fileps
		tags
		reference cells
		arrays
		handlers
		conversions
	Exceptions
		new handler
		raise (cannot propagate past ImptK)
		handle
	First-class control
		caputure (cannot propagate past ImptK)
		Ks is an applicative
		guards (onWind, onUnwind, onAbort)
	match literals
	abstract types
	objects and lists are self-evaluating, except those that have not yet been eval'd
		a primitive to construct a triple of (tag, constructor, deconstructor)
		we'll need a typeof operator, which returns a tag.
		might be nice to give names to types
	force import despite caching
	REPL
	Floating point primitive type
	re-raise exceptions?
		perhaps by keeping the last unwond stack around until a handler returns normally
		on re-raise, we simply cat the stacks
		alternately, do it as a library

Documentation
	geting started
	definition
	Octopus for (JS, OOlang, Lisp, ...) Programmers
	every primitive type and operation: what they do and when/how they fail

Cleanup
	Exposed modules use unallocated top-level names: Octopus
	put Shortcuts in Octopus.Data
	eliminate magic field names
	make an actual lookup primitive, desugar :x into that instead of into __get__

Tooling
	grotto (virtualenv)
	Packaging
		may as well design it general:
		the package metadata should describe the target language
		that way, I can use the same protocols for Octopus, Murex and Nautilus
	lint/runtime warnings:
		detect no parenthesis on a multi-expression do line (statement or expression)
		possible misspellings (rough analysis of do blocks, especially note similar spellings)
		unsafe filenames (target the lowest common denominator)
		malformed type names (these should have a standard form, like /\w+(\.\s+)*/)
		warn about rebinding double-underscore symbols
	When you run the interpreter, allow for hooks.
		Say you do `octopus "somefile.oct", then we should look up from configuration a list of commands to run when a file is provided. The is given to these commands and each command is run. If all the commands succeed, then we send the file (which many have been modified, say by unicoder) into the interpreter.

Performance
	Extended data primitves
	Applicative closures?
	try using `Rose (Map Symbol (Maybe Val))` for objects to reduce space consumption
		The maybe val is there so that a lookup can return (Just Nothing), which is equivalent to (Nothing)

Standard libraries
	simulate (parametric) modules (thereby typeclasses minus ad hoc)
	monads (including monadic IO)
	structured data
		html
		annotated sexpr protocol (generalizing html/xml)
		metadata protocol
		d3-style joins
	parsers (glob, regular, context-free, CFG+static alloc'd storage, combinator)
	servers
		conduits
		string builders
		sockets
		databases
	stm
	mutable objects/smalltalk


