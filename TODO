TODO

General
	better pretty-print
		show as octopus parses, not as haskell does
		apply judicious indentation
		the angle brackets are ambiguous, use #<...>
	serialize values, even mutable cells and the current program state
	consider putting types into the grammar, unchecked of course

Parser
	letrec
	open statement
		takes an object, uses that obj to extend the env for the rest of the do/file
		could be used to ease ad-hoc overloading: in particulat, open a monad, then perform monadic computations w/o mentioning the monad explicitly
	distfixes
		directives are line tht start with #! (though #! on very first line is ignored)
		massage the input by blanking these lines, but also collect and parse the directives
	literate files
	export form in file
		currently, it exports the whole environment
		a way to give out a limited set would be very useful
		export ::= 'export' <pattern>
	anonymous points
	block comments
	bytes literals
	documentation on a (define? export?)
	decorators in do blocks
	import form objects
		{x, y, z: foo} === {x: x, y: y, z: foo}
	indentation sensitivity?
		each indent, open paren/brack/brace/do gets pushed onto the stack
		an indent means going further than the last column of the peek
		a dedent means not going as far as the pop
	ellipsis?
	literals for closures, tags, handlers, &c (using #<...> syntax)?
	special syntax for lambda and vau
		use the primitive ones, allow for stuff like (\l (x y z) body)
		nah, I can do this in userland

Interpreter
	BUGFIX: tags are created local to a thread, either:
		make a tag generator thread-global
		attach a threadid to the tag
	Data primitives
		fileps
		tags
		abstypes
		reference cells
		arrays
		handlers
		conversions
	First-class control
		caputure (cannot propagate past ImptK)
		Ks is an applicative
		guards (onWind, onUnwind, onAbort)
	match literals
	abstract types
	BUGFIX: objects and lists should be self-evaluating, except those that have not yet been eval'd
	a primitive to construct a triple of (tag, constructor, deconstructor)
	we'll need a typeof operator, which returns a tag.
	might be nice to give names to types
	force import despite caching
	pass arbitrary flags to interpreter (like -D in gcc), look them up at runtime
	REPL
	Floating point primitive type
	version specifier in import string
	re-raise exceptions?
		perhaps by keeping the last unwond stack around until a handler returns normally
		on re-raise, we simply cat the stacks
		alternately, do it as a library

Documentation
	geting started
	definition
	Octopus for (JS, OOlang, Lisp, ...) Programmers
	every primitive type and operation: what they do and when/how they fail

Cleanup
	Exposed modules use unallocated top-level names: Octopus
	put Shortcuts in Octopus.Data
	eliminate magic field names
	make an actual lookup primitive, desugar :x into that instead of into __get__

Tooling
	grotto (virtualenv)
	Packaging
		may as well design it general:
		the package metadata should describe the target language
		that way, I can use the same protocols for Octopus, Murex and Nautilus
	lint/runtime warnings:
		detect no parenthesis on a multi-expression do line (statement or expression)
		possible misspellings (rough analysis of do blocks, especially note similar spellings)
		unsafe filenames (target the lowest common denominator)
		malformed type names (these should have a standard form, like /\w+(\.\s+)*/)
		warn about rebinding double-underscore symbols
		warn about use of tabs
	When you run the interpreter, allow for hooks.
		Say you do `octopus "somefile.oct"`, then we should look up from configuration a list of commands to run when a file is provided. The is given to these commands and each command is run. If all the commands succeed, then we send the file (which many have been modified, say by unicoder) into the interpreter.
	Perform imports statically (may require an import keyword)

Performance
	Extended data primitves
	Applicative closures?
	try using `Rose (Map Symbol (Maybe Val))` for objects to reduce space consumption
		The maybe val is there so that a lookup can return (Just Nothing), which is equivalent to (Nothing)

Standard libraries
	os interface
	first-class patterns
	translate type errors: catch a type error underneath, then throw a new type error with a new origin
	simulate (parametric) modules (thereby typeclasses minus ad hoc)
	monads (including monadic IO)
	structured data
		html
		annotated sexpr protocol (generalizing html/xml)
		metadata protocol
		d3-style joins
	parsers (glob, regular, context-free, CFG+static alloc'd storage, combinator)
	servers
		conduits
		string builders
		sockets
		databases
	stm
	mutable objects/smalltalk


